#include <bits/stdc++.h>
using namespace std;

int a[4][8], K, idx, dir, check[4], ans;

void rot(int idx, int dir) { // dir 0, -1, 1
    if (dir == -1) {         // 반시계
        int tmp = a[idx][0];
        for (int i = 1; i < 8; ++i) {
            a[idx][i - 1] = a[idx][i];
        }
        a[idx][7] = tmp;
    } else if (dir == 1) { // 시계
        int tmp = a[idx][7];
        for (int i = 6; i >= 0; --i) {
            a[idx][i + 1] = a[idx][i];
        }
        a[idx][0] = tmp;
    }
}

void simulate(int idx, int dir) {
    memset(check, 0, sizeof(check));
    check[idx] = dir;

    for (int i = idx; i < 3; ++i) { // 기준에서 오른쪽 체크
        if (a[i][2] != a[i + 1][6]) check[i + 1] = -check[i];
    }
    for (int i = idx; i > 0; --i) {
        if (a[i][6] != a[i - 1][2]) check[i - 1] = -check[i];
    }

    for (int i = 0; i < 4; ++i) {
        rot(i, check[i]);
    }
}

int main() {
    for (int i = 0; i < 4; ++i) {
        for (int j = 0; j < 8; ++j) {
            scanf("%1d", &a[i][j]);
        }
    }
    cin >> K;
    while (K--) {
        cin >> idx >> dir;
        simulate(idx - 1, dir);
    }

    for (int i = 0; i < 4; ++i) {
        ans += (1 << i) * a[i][0];
    }
    cout << ans;
    return 0;
}

/*
1. 문제 읽기
2. 논리적 순서
3. 필요한 자료연산 리스트업
4. 자료형, 시간복잡도, 유리한 자료구조 선택
5. 구현
6. 엣지케이스

1. 8개의 톱니 가진 톱니바퀴 1,2,3,4번, N극0, S극1 이 있음
톱니바퀴를 한칸씩 K번 시계방향, 반시계방향 회전
맞닿는 극에 따라서 옆 톱니바퀴를 회전할수도 안할수도
A를 회전하는데 옆 B와 맞닿은 톱니극이 다르면 B는 반대방향으로 회전
톱니바퀴의 초기상태, 회전방법이 주어짐 => 최종 톱니바퀴 상태 반환
1,2,3,4 톱니바퀴 상태 주어짐 12시방향부터 시계방향으로
회전횟수 K 1~100, 회전시킨 톱니바퀴 번호, 방향+1, -1

2.
1.다 배열로 상태 저장한다, 회전하는지 여부도 상태로 저장
2. 한 라운드마다 시작위치로부터 왼쪽, 오른쪽 전부 확인하고 회전 여부,방향 체크
시계방향 회전, 반시계 회전방향 상태 1, -1
3. 순회하면서 돌아가는거면 회전시키고 라운드 종료


A. 정확히 이해하고 넘어가자
1. 질문을 정리하다보니 해결되는 경우가 많음

2. 짝에게 서로 설명해주는 방식으로 이해하자
Ex) 관찰을 해보니 ~~라는 특성이 있습니다. 이걸 이용해서 ~~ 접근을 시도했습니다. 여기까지 궁금하신 점이 있으까요?
-> 네 잘 이해했습니다. Or 이 부분이 이해가 안갑니다.

3. 주석을 열심히 달면서 풀어보기
주석을 문장 형태를 이뤄서 작성하다 보면 어색한 부분은 전부 제대로 이해하지 못한 것이다. 변수들은 의미를 설명하기 함수들은 입출력, 시간복잡도를
설명하기. 각 줄마다 문장으로 설명하기

B. 시간을 정해놓고 풀자
- 삼성기출, 골드: 2시간, 실버: 1시간
- 시간이 지나면 빠르게 해설보고 이해한 뒤, 코드를 전부 지우고 다시 처음부터 반복한다.
다시 풀었을 때
1. 막히던 부분이 해결되는지 확인
2. 실수가 줄어드는지 확인
시간이 줄어드는지 확인

C. 복잡도, 어려웠던 부분 체크
1. 시간복잡도는? -> step마다 계산하고 설명
2. 공간복잡도는? -> 사용한 자료구조마다 계산, 설명
3. 어려웠던 부분은? -> 어떻게 해결했는지 설명하기
*/
import sys
si = sys.stdin.readline

N = int(si())
a = [0] * 301
d = [[0 for _ in range(301)] for _ in range(3)]

for i in range(1, N + 1):
    a[i] = int(si())

d[1][1], d[1][2], d[2][2] = a[1], a[2], a[1] + a[2]
for j in range(3, N + 1):
    d[1][j] = max(d[1][j - 2], d[2][j - 2]) + a[j]
    d[2][j] = d[1][j - 1] + a[j]

print(max(d[1][N], d[2][N]))

'''
1. 문제 읽기
2. 논리적 순서
3. 필요한 자료연산 리스트업
4. 자료형, 시간복잡도, 유리한 자료구조 선택
5. 구현
6. 엣지케이스

1. 계단오르기. 
- 한번에 1, 2개씩 올라감
- 연속된 3개를 밟으면 안됨, 시작점은 뺀다
- 마지막 도착 계단은 밟아야됨 이 게임의 점수 최대값구하기
N 1~300

2. d[i] = i를 밟았을 때 총 점수 최대값
d[i] = max(d[i - 1], d[i - 2]) + a[i], i <= 300
d[0] = 0, d[1] = a[1], 이렇게 하면 연속된 3개 계단 상태를 모름

2. d[i][j] = 연속해서 i개 계단을 밟았을 때 j번 계단에서의 점수 최대값
- 2계단 올라와서 1개연속 
- 1계단 올라와서 2개연속 -> d[1][1] = 1계단 올라와서 1개 연속

d[1][j] = max(d[1][j - 2], d[2][j - 2]) + a[j] # 1개연속, 2칸점프, 2개연속, 2칸점프
d[2][j] = d[1][j - 1] + a[j] # 1개연속, 1칸점프해서 2개연속이 됨
d[1][1] = a[1]
d[1][2] = a[2]
d[2][2] = a[1] + a[2] 2칸 연속

2-2. 
d[i] = i번째 계단까지 올라섰을 때 밟지 않을 계단의 합의 최솟값, i번째 계단은 반드시 밟지 않을 계단으로 선택
d[1] = a[1], d[2] = a[2], d[3] = a[3]
d[i] = min(d[i - 2], d[i - 3]) + a[i], i >= 4

d[1] = 10, d[2] = 20, d[3] = 15, d[4] = 35 d[5] = 25
k 계단을 안밟으려면 k - 2, k- 3 중 하나를 안 밟아아야됨
'''
